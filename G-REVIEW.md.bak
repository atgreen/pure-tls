# pure-tls Security Audit (Augmented Review)

This document details the findings of a security audit of the pure-tls Common Lisp library, augmented with findings from an independent review.

## Summary of Findings

| ID | Severity | Title | Status |
|---|---|---|---|
| 001 | Critical | Missing Elliptic Curve Public Key Validation | Reported |
| 002 | High | Incomplete Certificate Chain Verification | Reported |
| 003 | High | Custom RSA PKCS#1 v1.5 Signature Verification | Reported |
| 004 | High | AES-GCM Key Size Not Differentiated | Reported |
| 005 | High | Hostname Verification Bypasses | Reported |
| 006 | Medium | Certificate Verification Can Be Bypassed by API Misuse | Reported |
| 007 | Medium | Inadequate Server Ticket Key Management | Reported |
| 008 | Medium | Insufficient Robustness in Handshake Parsing | Reported |
| 009 | Medium | Complex ECDSA Signature Handling | Reported |
| 010 | Medium | Weak Client Certificate Validation in mTLS | Reported |
| 011 | Medium | RSA-PSS Certificate Signatures Ignore Parameters | Reported |
| 012 | Low | Fragile Use of Unexported Symbol | Reported |
| 013 | Low | ASN.1 Parser Complexity | Reported |
| 014 | Low | PSK Binder Transcript Truncation is Incorrect | Reported |
| 015 | Low | Record Layer Does Not Validate Legacy Version | Reported |

## Detailed Findings

### 001: Missing Elliptic Curve Public Key Validation
**Severity**: Critical
**Location**: `src/crypto/key-exchange.lisp`
**Description**: The `secp256r1-compute-shared-secret` function does not validate that the peer's public key is a valid point on the secp256r1 curve. Furthermore, for X25519, the implementation does not check for an all-zero shared secret, which is a required check in TLS 1.3. An attacker can provide a specially crafted public key to conduct a small subgroup or invalid-point attack, which could allow them to determine the shared secret and compromise the TLS session.
**Recommendation**: Explicitly validate the peer's public key to ensure it is a valid point on the curve before computing the shared secret. After ECDH, reject any all-zero shared secrets, especially for X25519.

### 002: Incomplete Certificate Chain Verification
**Severity**: High
**Location**: `src/x509/verify.lisp`
**Description**: The pure Lisp certificate chain verification logic in `verify-certificate-chain` is incomplete. It checks signatures and issuer/subject names, but it fails to validate critical extensions like `BasicConstraints` (to ensure an intermediate certificate is a CA and the path length is not exceeded), `KeyUsage` (to ensure the CA is allowed to sign certificates), and does not reject unknown critical extensions. This could allow an attacker to use a valid, but non-CA, certificate to issue a fraudulent certificate for a target domain.
**Recommendation**: Implement the missing checks for `BasicConstraints` and `KeyUsage` in the chain verification logic. The verifier must check that the `cA` flag is true and the `keyCertSign` bit is set for all issuing certificates. It must also enforce `pathLenConstraint` and reject any certificate with an unknown critical extension.

### 003: Custom RSA PKCS#1 v1.5 Signature Verification
**Severity**: High
**Location**: `src/x509/verify.lisp`
**Description**: The `verify-rsa-pkcs1v15-signature` function implements a custom verification of RSA PKCS#1 v1.5 signatures. This involves manually parsing the decrypted signature data to check the padding and DigestInfo structure. This is a highly security-sensitive operation, and a small bug (e.g., not enforcing a minimum of 8 bytes of 0xFF padding) could lead to a signature validation bypass. The implementation also accepts SHA-1 signatures, which are deprecated.
**Recommendation**: Replace the custom RSA PKCS#1 v1.5 verification logic with a call to the Ironclad library's `verify-signature` function with the `:pkcs1v15` mode. Reject certificates using SHA-1 signature algorithms.

### 004: AES-GCM Key Size Not Differentiated
**Severity**: High
**Location**: `src/crypto/aead.lisp`
**Description**: The `aes-gcm-encrypt` and `aes-gcm-decrypt` functions do not correctly differentiate between AES-128 and AES-256 based on the key length. The code uses `(if (= (length key) 16) :aes :aes)`, which results in the same cipher being used for both key sizes.
**Recommendation**: Replace the incorrect logic with a `case` statement that explicitly selects the correct Ironclad cipher name based on the key length (`:aes-128` for 16 bytes, `:aes-256` for 32 bytes).

### 005: Hostname Verification Bypasses
**Severity**: High
**Location**: `src/x509/verify.lisp`
**Description**: The hostname verification logic has several weaknesses. The wildcard matching in `wildcard-hostname-matches-p` is too broad and would accept patterns like `*.com`. It does not handle public suffix rules or IDNA (punycode) normalization. Furthermore, the verifier only checks for DNS names in the SAN and CN, ignoring IP Address SANs.
**Recommendation**: Enforce stricter wildcard matching rules as specified in RFC 6125 (e.g., reject wildcards on public suffixes). Add support for matching IP Address SANs and normalize IDNA hostnames before comparison.

### 006: Certificate Verification Can Be Bypassed by API Misuse
**Severity**: Medium
**Location**: `src/handshake/client.lisp`, `src/streams.lisp`
**Description**: The main `perform-client-handshake` function does not enforce certificate chain and hostname validation. This is deferred to the `make-tls-client-stream` helper function. If a developer uses the lower-level handshake API directly, they could end up with an unauthenticated connection, even if `verify-mode` is set to `+verify-required+`.
**Recommendation**: Move the certificate verification logic inside `perform-client-handshake` to ensure that verification is always performed when required.

### 007: Inadequate Server Ticket Key Management
**Severity**: Medium
**Location**: `src/handshake/resumption.lisp`
**Description**: The server-side session ticket encryption relies on a global variable `*server-ticket-key*`. This key is not rotated or persisted, meaning it is lost on restart (invalidating all tickets) and a compromised key is valid indefinitely. In a multi-server environment, each server would have a different key, preventing session resumption across instances.
**Recommendation**: Implement a more robust key management solution for session tickets, including key rotation, persistence, and a mechanism for sharing the key across multiple server instances.

### 008: Insufficient Robustness in Handshake Parsing
**Severity**: Medium
**Location**: `src/handshake/messages.lisp`, `src/handshake/extensions.lisp`
**Description**: The handshake message and extension parsing code may not be sufficiently robust against malformed or malicious inputs. An attacker could send messages with incorrect lengths or structures to trigger an error and cause a denial of service.
**Recommendation**: Thoroughly review and test the parsing code with a wide range of malformed inputs (fuzz testing). Add more stringent checks for lengths and boundaries.

### 009: Complex ECDSA Signature Handling
**Severity**: Medium
**Location**: `src/handshake/client.lisp`
**Description**: The `verify-ecdsa-signature` function manually parses the DER-encoded ECDSA signature from the peer to extract the `r` and `s` values. This is a complex and error-prone process. A bug in the DER parsing code could lead to a signature validation bypass.
**Recommendation**: Investigate if the Ironclad library can directly verify a DER-encoded ECDSA signature. If so, refactor the code to use that functionality.

### 010: Weak Client Certificate Validation in mTLS
**Severity**: Medium
**Location**: `src/handshake/server.lisp`
**Description**: In an mTLS scenario, `process-client-certificate-verify` only performs chain validation if a `trust-store` is configured. If `verify-mode` is `+verify-required+` but no trust store is provided, an untrusted client certificate could be accepted.
**Recommendation**: Enforce that a trust store is present whenever `verify-mode` is `+verify-required+` and fail the handshake if it is missing.

### 011: RSA-PSS Certificate Signatures Ignore Parameters
**Severity**: Medium
**Location**: `src/x509/verify.lisp`
**Description**: The RSA-PSS signature verification for certificates ignores the signature parameters (hash, salt length, etc.) and defaults to SHA-256. This is non-compliant and could lead to incorrect validation results.
**Recommendation**: Parse and enforce the RSA-PSS parameters from the `AlgorithmIdentifier` in the certificate.

### 012: Fragile Use of Unexported Symbol
**Severity**: Low
**Location**: `src/crypto/key-exchange.lisp`
**Description**: The code accesses an unexported symbol (`ironclad::y`) from the Ironclad library. This creates a fragile dependency on the internal implementation of Ironclad, which could break with future updates.
**Recommendation**: Use an exported function or accessor from Ironclad if one is available.

### 013: ASN.1 Parser Complexity
**Severity**: Low
**Location**: `src/x509/asn1.lisp`
**Description**: The security of the certificate parsing depends on the correctness of the ASN.1/DER parser. While no specific bugs were found, it is a complex piece of code. A subtle bug could be exploited to cause a denial of service or a validation bypass.
**Recommendation**: Consider using a well-tested, third-party ASN.1 parsing library if one is available. If not, the custom parser should be subjected to extensive fuzz testing.

### 014: PSK Binder Transcript Truncation is Incorrect
**Severity**: Low
**Location**: `src/handshake/server.lisp`
**Description**: The server-side PSK binder verification truncates the ClientHello transcript incorrectly. It subtracts the length of the binder data but not the length of the binder list field itself, causing a mismatch with the client's calculation and leading to session resumption failures.
**Recommendation**: Correct the transcript truncation logic to match the client-side calculation, ensuring it accounts for the entire binders structure.

### 015: Record Layer Does Not Validate Legacy Version
**Severity**: Low
**Location**: `src/record/record-layer.lisp`
**Description**: The record layer does not validate that the `legacy_record_version` field is `0x0303` on inbound records, as required by the TLS 1.3 specification.
**Recommendation**: Add a check to enforce that the `legacy_record_version` is `0x0303` for all inbound records.

## Other Areas Reviewed

### Record Layer
**Location**: `src/record/record-layer.lisp`
The record layer implementation was reviewed and found to be straightforward. It properly handles record size limits, short reads, and alert messages. A minor compliance issue was noted (see finding #015).
